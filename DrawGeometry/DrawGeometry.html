<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Drawing on canvas </title>
	<link rel="stylesheet" type="text/css" href="../libs/style.css">
	<script src="../libs/run_prettify.js?autoload=true&amp;lang=css" defer=""></script>
	<script src="../libs/WebGeometry.js"></script>
	<script src="../libs/canvas2D.js"></script>
	<script src="canvas_draw.js"></script>

	<style>
		div.out
		{
			position: relative;
			width: 780px;
			height: 412px;
			left: 5px;
			background-color: #aaffff;
			border: solid 2px;
		}
	
		div.canvas
		{
			position: absolute;
			left: 5px;
			top: 5px;			
			width: 770px;  /* ширина холста*/
			height: 400px; /* высота холста*/
			background-color: #fcffff;
			border: solid 0px;		
		}	
	</style>

</head>

<body oncontextmenu="return false">

<h4 align = "center">&emsp;&emsp;
<a href="../Octagon/Preface.html"> <span class=purple>Введение.</span></a>  <span class=purple>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=purple> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=purple>► &ensp;</span></a><a href="../Octagon/Octagon1.html"> <span class=purple>Многогранник октагон&emsp;Часть &#8544;.</span></a>
</h4>

<br>

</p>
<h2 align = "center"> Черчение на холсте при помощи библиотеки canvas2D</h2>

<p>
Для отображения объектов на холсте создана специальная библиотека <b>canvas2D</b>, которая позволяет использовать
на нем <em>прямоугольную декартову систему координат</em> с привычным направлением осей <b>X</b> и <b>Y</b>. 
</p>
В стандартной системе координат принятой в <b>HTML5</b> для холста (<b>canvas</b>) координаты отсчитываются 
от точки находящейся в левом верхнем углу, которая принята за начало координат. Координаты 
увеличиваются в горизонтальном направлении вдоль оси <b>X</b> и в вертикальном - <b><em>вниз</em></b> вдоль оси <b>Y</b>. 
Такой выбор направления осей отличается от выбора осей в аналитической геометрии в которой 
ось <b>Y</b> направлена <b><em>вверх</em></b>.
</p>

<p>
Так как в дальнейшем мы предполагаем отображать на холсте проекции геометрических объектов (моделей) 
на плоскость <b>OXY</b>, то необходимо согласовать систему координат в которой производится расчет положения вершин  
этих объектов со стандартной системой координат холста <b>HTML5</b>. Все расчеты координат вершин геометрических объектов
в дальнейшем будут производиться при помощи <b>JS</b> библиотеки 
<b><a href="https://vlad0007.github.io/polyhedron1/libs/Help.html" target="_blank">WebGeometry</a></b>
(сокращенно - <b>WG</b>) в которой используется
система координат совпадающая с системой координат принятой в аналитической геометрии. Поэтому при 
выводе изображений на холст требуется направить ось <b>Y</b> не <b><em>вниз</em></b> как в стандартной системе 
координат холста <b>HTML5</b>, а <b><em>вверх</em></b>. 
</p>

<div class="out">  
	<div class="canvas"> <!-- смотри div.canvas в начале файла -->
		<canvas id="canvas_draw" width="770" height="400" style="border: 1px solid"></canvas>
	</div>
</div>
<p>


<p>
Численные значения координат в <b>HTML5 Canvas</b> выражаются в пикселах. 
В расчетах координат вершин моделей, которые мы создадим, будут получаться
как положительные так и отрицательные значения. Поэтому потребуется поместить начало 
координат скорее всего не в левый верхний угол холста, а в какое-то другое место на холсте.
</p>

<p>
Предположим, что в нашей декартовой системе координат значения лежат в интервале от <b>-3</b> до <b>3</b>,
а холст имеет размеры <b>700 x 400</b> пикселов. Поэтому потребуется привести в соответствие
(масштабировать) эти величины. Сам холст, который имеет фиксированные размеры,
можно рассматривать просто как некоторое <b><em>окно</em></b>, через которое мы рассматриваем изображения объектов
на плоскости и находящейся на этой плоскости декартовой системе координат <b>OXY</b>. 
Нажмите левую клавишу мыши и перемещайте мышь по холсту в <em>online</em>-программе помещенную на данную <b>WEB</b>-страницу.
Вы увидете как на холсте (за <b><em>окном</em></b>) изменяется вид изображения - появляются новые геометрические
объекты. При помощи поворота колесика мыши (если мышь находится на холсте) можно осуществлять 
масштабирование изображений объектов.
</p>

<p>
Рассмотрим как использовать функции библиотеки <b>canvas2D</b> (справочник по функциям этой библиотеки можно
найти перейдя по ссылке <b><a href="../libs/Canvas2d_Reference.html" target="_blank">Canvas2d Reference</a></b>).
В файле <b>canvas_draw.js</b> находится исходный текст показанной выше <em>online</em>-программы.
</p>
Прежде всего в программе необходимо объявить и задать значения глобальных переменных <b>xC</b>, <b>yC</b> и <b>SCALE</b>:
<p>

</p>

<pre>
	 <b>SCALE</b> задает <em>исходный</em> масштаб при рисовании проекции модели на плоскость <b>OXY</b>,
	Представим, что значения координат модели в <b>WebGeometry</b> по <b>X</b> и <b>Y</b>
	находятся в пределах от <b>-3.0</b> до <b>+3.0</b>, а холст имеет размеры <b>770 x 400</b>.
	 Для приведения в соответствии значений в этих двух системах координат 
	используется коэффициент масштабирования <b>SCALE</b>. 
	<b>SCALE = 250</b>;
	<b>xC</b> и <b>yC</b> задают координаты точки на на холсте в пикселах 
	имеющую координаты <b>(0, 0)</b> в системе координат <b>WebGeometry</b>
	<b>xC = 23</b> - пиксела вправо по холсту
                770 - размер холста по горизонтали в пикселах   
	<b>yC = 400 - 15 = 385</b> - пикселов вниз по холсту 
                400 - размер холста по вертикали в пикселах
	 Таким образом начало координат в системе WG находится неподалеку от левого
	нижнего угла холста (смотри <em>online</em>-программу выше на странице).
</pre>	
 В рассматриваемой <em>online</em>-программе при движении мыши по холсту 
если леваяя клавиша мыши <b>нажата</b> то происходит движение чертежа за <b><em>окном</em></b> просмотра.
Если же клавиша мыши <b>НЕ нажата</b>, то при движении мыши 
происходит отображение тех координат  в системе <b>WG</b>, 
которые соответствуют положению курсора мыши на холсте
(мелкий шрифт рядом с острием стрелки курсора):


<pre class="prettyprint" id="quine">
	function handleMouseMove(event) 
	{
		if (mouseDown) 
		{	
			// если клавиша мыши нажата, то двигаем изображения на холсте
			var newX = event.clientX; // текущие значения положения 
			var newY = event.clientY; // мыши на холсте
			
			var d = 7.0; // шаг смещения "окна" просмотра

			var deltaX = newX - lastMouseX;
			if (deltaX < 0)
			{
				xC = xC - d;
			}
			if (deltaX > 0)
			{
				xC = xC + d; 
			}
			
			var deltaY = newY - lastMouseY;
			if (deltaY < 0)
			{
				yC = yC - d;
			}
			if (deltaY > 0)
			{
				yC = yC + d;
			}

			lastMouseX = newX // сохраняем в глобальных переменных
			lastMouseY = newY; // текущие значения положения мыши
			
			// отображение на экран
			draw();	
		}
		else 
		{
			// если клавиша мыши НЕ нажата, то выводим координаты (WG) точки 
			// на которой находится курсор мыши
			event.preventDefault();
			elem = document.getElementById('canvas_draw');
			coords = elem.getBoundingClientRect();	

			// координаты мыши 	
			var x_mouse, y_mouse;

			// координаты мыши на холсте (canvas_draw)
			x_mouse = event.clientX - coords.left;
			y_mouse = event.clientY - coords.top;	

			// приводим координаты мыши к WebGeometry (WG)
			x_coord = (x_mouse - xC)/SCALE;
			y_coord = (yC - y_mouse)/SCALE;
			
			// отображение на экран
			draw();
		}
	}
</pre>

<p>
Заметим, что в <b><em>последующих программах</em></b> при движении мыши по холсту, чтобы не загромождать
интересные места на холсте, вывод координат (при ненажатой левой клавиши мыши) будет
производиться всегда в фиксированном месте - в <em>левой верхней части холста</em>.<br>
При движении мыши по холсту и нажатой левой ее клавиши в дальнейших программах будет 
осуществвляться <em>не перемещения</em>, а <em>вращение</em> <b>3D</b>-моделей которые мы в этих прграммах создадим.
<br>
&emsp; Масштабирование моделей будет осуществляться не вращением колесика мыши, а заданием 
соответствующего значения в панели <b>GUI</b>.
</p>

<p>
Функции входящие в библиотеку <b>canvas2D</b> сделаны полностью <em>на основе</em> функций входящих в состав <b>HTML5 Canvas</b>,
но с одним <em>принципиальным</em> отличием от них. В функциях <b>HTML5 Canvas</b> в качестве координат объектов
(текста, линий, полигонов, ...) задаются <em>координаты стандартного холста</em>, а в функциях
<b>canvas2D</b> напрямую задаются <em>декартовы координаты</em>, которые используются в библиотеке <b>WebGeometry (WG)</b>.
Тем самым программист, после того как он задал значения <b>xC, yC</b> и <b>SCALE</b> не должен заботиться о 
преобразовании одной системы координат в другую при отображении объектов на холсте. Все функции 
входящие в <b>canvas2D</b> созданы таким образом, чтобы с их помощью можно было без труда визуализировать
результаты расчетов произведенных с использованием библиотеки <b>WebGeometry</b>. Иными словами <b>canvas2D</b>
можно считать дополнением к библиотеке <b>WebGeometry</b>.
</p>

<p>
Использование большинства функций библиотеки <b>canvas2D</b> продемонстрировано в <em>online</em>-программе на текущей
<b>WEB</b>-странице. 
Исходный текст этой программы расположен в файле <b>canvas_draw.js</b>. Описание функций библиотеки <b>canvas2D</b>
находится по ссылке 
<b><a href="../libs/Canvas2d_Reference.html" target="_blank">Справочник по функциям canvas2d</a></b>.
</p>
<p>
Еще примеры использования функций библиотеки <b>canvas2D</b> можно найти на <b>WEB</b>-страницах моего другого сайта:<br>
<b><a href="https://vlad0007.github.io/polyhedron1/Plane/Chapter_03.html" target="_blank">Библиотека WebGeometry и холст HTML5 (часть 1)</a></b>,
<br>
<b><a href="https://vlad0007.github.io/polyhedron1/Plane/Chapter_04.html" target="_blank">Библиотека WebGeometry и холст HTML5 (часть 2)</a></b>,
<br>
<b><a href="https://vlad0007.github.io/polyhedron2/Marquise/Chapter_14.html" target="_blank">Рундист огранки маркиз</a></b>,
<br>
<b><a href="https://vlad0007.github.io/polyhedron2/Pear/Chapter_17.html" target="_blank">Построение рундиста огранки имеющей рундист в форме груши</a></b>,
<br>
<b><a href="https://vlad0007.github.io/polyhedron2/Heart/Chapter_20.html" target="_blank">Построение рундиста огранки сердце</a></b>,
<br>
<b><a href="https://vlad0007.github.io/polyhedron2/Cushion/Chapter_23.html" target="_blank">Построение рундиста огранки имеющей рундист в форме "подушки"</a></b>,
<br>
<b><a href="https://vlad0007.github.io/polyhedron2/Trilliant/Chapter_28.html" target="_blank">Рундист огранки треугольная "подушка"</a></b>.
<br>
Заметим, что в программах, на которые указывают приведенные выше семь ссылок, использовалась предыдущая версия
библиотеки <b>canvas2D</b>. В новой (текущей) версии библиотеки исключена функция <code>line</code> (она не всегда работает корректно).
Вместо этой функции введены две новые - <code>line_ext</code> и <code>line_ext2</code>.
Функции <code>line</code>, <code>line_ext</code> и <code>line_ext2</code> предназначены для черчения выносных линий
при нанесении размеров объектов.
В некоторые другие функции по сравнению с первым вариантом библиотеки <b>canvas2D</b> введены дополнительные параметры 
в конце списка параметров и сделаны другие незначительные изменения.
</p>

<p>
Как можно увидеть из справочника по функциям  <b>canvas2D</b>, в состав библиотеки входят функции для рисования 
точек, прямых, сегментов прямых, дуг, полигонов, координатной сетки и текста. Координаты, задающие
положение на холсте этих объектов, можно задать двумя способами.<br>
 Первый способ заключается в том, что можно явно задать координаты объекта. 
 Например, квадратную точку красного цвета
размером в <b>4</b> пиксела и имеющую декартовы координаты <b>(0.5, 1.0)</b> можно задать следующим образом:
<pre>
  <code>var point = new Point2D(0.5, 1.0);</code>
  <code>rsp(ctx, point, 4, "R");</code> // отображаем квадратную точку на холсте
  
    Или так (теперь круглая точка):
  <code>сsp(ctx, new Point2D(0.5, 1.0), 4, "R");</code> // отображаем круглую точку на холсте
 
   Следует сказать несколько слов про функции <code>text, text1</code> и <code>text2</code> предназначенные для вывода 
   текста в библиотеке <b>canvas2D</b>.
     В основном мы будем использовать эти функции для обозначения конкретных точек на холсте. 
   Функции text1 и text2 обеспечивают некоторый "<em>зазор</em>" между непосредственно координатой 
   точки и текстом обозначающим эту точку. Функция <code>text</code> - без "<em>зазора</em>".
       Точка <code>Point2D(0.5, 1.0)</code> используется и для задания координаты самой точки 
     в <code>csp</code> и для задания точки начала вывода текста в <code>text1</code> с небольшим "<em>зазором</em>" от
     от <code>Point2D(0.5, 1.0)</code>.
    Над точкой с координатами <code>Point2D(0.5, 1.0)</code> отображаем красный текст "This point !"
  <code>text1(ctx, "This point !", new Point2D(0.5, 1.0), "center", "up", "R");</code>
</pre>

 При втором способе следует предварительно вычислить координаты объекта. Предположим,
что точка определена пересечением двух прямых (смотри описание функций входящих в библиотеку
<b><a href="https://vlad0007.github.io/polyhedron1/libs/Help.html" target="_blank">WebGeometry</a></b>:
<pre>
  // Создаем первую прямую проходящую через точки (-1.0, -1.0) и (1.0, 1.0)
  <code>var line1 = new Line2D( new Point2D(-1.0,-1.0), new Point2D(1.0, 1.0));</code>
  // Создаем вторую прямую проходящую через точки (-1.0, 1.0) и (1.0, -1.0)
  <code>var line2 = new Line2D( new Point2D(-1.0, 1.0), new Point2D(1.0,-1.0));</code>
  // Находим точку пересечения двух прямых
  <code>var point = line1.IntersectionTwoLines(line2);</code> // вычисляем положение точки
  <code>rsp(ctx, point, 4, "R");</code> // отображаем точку на холсте
</pre>

</p>

<p>
 Отдельно следует сказать про отображение на холсте рисунков. Для того, чтобы вывести рисунок на холст
используется стандартная функция <b>HTML5</b> <code>drawImage</code>. Например, для того чтобы вывести рисунок
в положение заданное при помощи декартовых координат <b>(1.0, 1.5)</b> следует использовать
следующее выражение:
     <br>
&nbsp; &nbsp; <code>ctx.drawImage(my_image, fx(1.0), fy(1.5), width, height);</code>
     <br>
&nbsp; Специальной функции в <b>canvas2D</b> для вывода изображений на холст не предусмотрено.
Но в <code>drawImage</code> функции <code>fx(1.0)</code> и <code>fy(1.5)</code> осуществляют 
преобразование декартовых координат в соответствующие координаты на холсте.
</p>

<pre>
Однако, с выводом на холст рисунков не все так просто. Чтобы выведенное на холст изображение не 
мигало на экране требуется сначала сделать следующие действия по сохранению изображения:
</pre>

<pre class="prettyprint" id="quine">
function init()		
{
    ..........
	..........
	var my_image = new Image();  
	if (!my_image) 
	{
		console.log('Ошибка при создании объекта!');
		return false;
	}
	
	// Загружаем изображение my_image ('brilliant.png')
	my_image.onload = function()
	{ 
		var width = 150; // 150 x 150 - размер кусочка холста
		var height = 150;
		// рисуем на холсте (можем выбрать произвольное место на холсте)
		ctx.drawImage(my_image, 0, 0, width, height);
		
		// Получаем объект image_data, содержащий копию 
		// пиксельных данных для заданной части холста
		image_data = ctx.getImageData(0, 0, width, height);
		image_load = true; // изображение сейчас загружено
							// и пиксельные данные получены
		draw(); // отрисовку всего холста производим после загрузки image
	};
	
	my_image.src = 'brilliant.png';	// изображение бриллианта хранится на сервере
                                    // или в локальном файле
	.......
}
									
</pre>
<pre>
 Как видно из приведенного выше куска программы, изображение просто выводится на холст в любом его
месте при помощифункции <code>drawImage</code>.  Сразу же после этого, используя функцию <b>HTML5 Canvas</b> 
<code>getImageData</code>, изображение сохраняется в объекте имеющем тип <code>ImageData</code>. 
Этот объект будет содержать копию пиксельных данных той части холста которая соответствует изображению.
 
 После этого мы можем в любой момент вывести на холст изображение при помощи функции
<b>HTML5 Canvas</b> <code>putImageData</code> предварительно поместив ее в функцию <code>draw</code>:
</pre>
<pre class="prettyprint" id="quine">
function draw()
{
	............
	............
	// Выводим на холст два одинаковых изображения сохраненных в image_data.
	if (image_load == true)
	{
		// (1.4, 2.4) - координаты места отрисовки (WG)
		ctx.putImageData(image_data, fx(-1.4), fy(2.4));
		// (1.2, -0.1) - координаты места отрисовки (WG)
		ctx.putImageData(image_data, fx(1.2), fy(-0.1));
	}
	............
	............
}
</pre>
<pre>
 При запуске приведенной выше online-программы на локальном компьютере (в ней производится 
загрузка изображения <b>'brilliant.png'</b> с диска того же локального компьютера),
требуется соответствующим образом настроить браузер. Если в качестве браузера 
используется <b>Chrome</b>, то в команду запуска <b>Chrome</b> следует добавить параметр командной 
строки <b>--allow-file-access-from-files</b>. Это обусловлено требованиями безопасности, 
так как по умолчанию <b>Chrome</b> запрещает доступ к локальным файлам. <b><code>Не забудьте</code></b>
вернуть браузер в его прежнее состояние после экспериментов, иначе вы оставите 
открытым доступ к локальным файлам, в обход системы безопасности.
</pre>

<p>
Вывод рисунков на холст в данной серии <b>WEB</b>-страниц нам больше не встретится. 
Но на странице  
<b><a href="https://vlad0007.github.io/Brilliant/BrilliantGirdle.html" target="_blank">Brilliant girdle</a></b> 
другого моего сайта <b><a href="https://vlad0007.github.io/" target="_blank">Diamond cuts</a></b> можно 
увидеть как при помощи функции <code>putImageData</code> на холст выводятся  математические формулы 
предварительно помещенные на рисунок.
</p>

<p>
В <a href="../Octagon/Octagon1.html"><b>следующем разделе</b></a> мы создадим первую <b>3D</b>-модель многогранника.
</p>
</body>
</html>	